#include <iostream>  // Подключаем библиотеку для ввода-вывода (std::cin, std::cout)
#include <string>    // Подключаем библиотеку для работы со строками (std::string)

using namespace std; // Чтобы не писать std:: перед cin, cout, string и т.д.

// Функция manual_trim — удаляет пробелы и символы табуляции '\t' в начале и конце строки
string manual_trim(const string& str) {
    size_t first = 0; // Индекс первого символа, который не пробел и не табуляция

    // Цикл пока:
    // - first меньше размера строки (чтобы не выйти за границы),
    // - И одновременно символ str[first] равен пробелу ' ' или табуляции '\t' 
    //(символ табуляции — это горизонтальный отступ, его обозначают '\t', что в памяти — один символ, но визуально он больше пробела)
    // Оператор && — это логическое И (AND), условие истинно, если оба выражения слева и справа — true.
    // Если левое (first < str.size()) ложно — правое не проверяется (короткое замыкание).
    while (first < str.size() && (str[first] == ' ' || str[first] == '\t')) 
        first++;  // Сдвигаем индекс вправо, пропуская пробелы и табуляции в начале строки

    // Если вся строка состояла из пробелов и табуляций (first дошел до конца строки)
    if (first == str.size())
        return ""; // Возвращаем пустую строку

    size_t last = str.size() - 1; // Индекс последнего символа строки (начинаем с конца)

    // Цикл пока:
    // - last больше first (чтобы не выйти за пределы подстроки),
    // - И символ str[last] равен пробелу или табуляции '\t'
    // Аналогично объяснение про оператор && выше
    while (last > first && (str[last] == ' ' || str[last] == '\t'))
        last--; // Сдвигаем индекс влево, пропуская пробелы и табуляции в конце строки

    // Возвращаем подстроку с первого "незапятнанного" символа до последнего включительно
    // substr(start, length) — start индекс, length — длина подстроки
    // last - first + 1 — длина, учитывая оба края
    return str.substr(first, last - first + 1);
}

// Функция поиска значения по ключу в строке вида "key=value,key2=value2"
// line — строка с парами ключ=значение, разделёнными запятыми
// key — искомый ключ
// found — флаг, указывающий, найден ли ключ (по ссылке, чтобы можно было сообщить результат)
string find_value_manually(const string& line, const string& key, bool& found) {
    found = false; // Изначально ключ не найден
    size_t pos = 0; // Начинаем поиск с начала строки

    // Цикл пока позиция меньше длины строки
    while (pos < line.size()) {
        // Ищем запятую, которая разделяет пары ключ=значение
        size_t comma = line.find(',', pos);
        // Если запятая не найдена, считаем, что это конец строки
        if (comma == string::npos) comma = line.size();

        // Получаем подстроку от текущей позиции до запятой (или до конца строки)
        string pair = line.substr(pos, comma - pos);

        // Ищем разделитель пары - первый символ '=' или '-'
        // find_first_of("-=") ищет первое вхождение любого из символов '-' или '='
        size_t sep = pair.find_first_of("-=");

        // Если разделитель найден
        if (sep != string::npos) {
            // Извлекаем ключ: подстрока от начала до разделителя
            string cur_key = manual_trim(pair.substr(0, sep)); // Убираем пробелы вокруг ключа
            // Извлекаем значение: подстрока после разделителя до конца пары
            string cur_val = manual_trim(pair.substr(sep + 1)); // Убираем пробелы вокруг значения

            // Если ключ не пустой и совпадает с искомым
            if (!cur_key.empty() && cur_key == key) {
                found = true; // Ключ найден
                return cur_val; // Возвращаем значение
            }
        }

        // Сдвигаем позицию после запятой для поиска следующей пары
        pos = comma + 1;
        // Пропускаем возможные пробелы после запятой
        while (pos < line.size() && line[pos] == ' ') pos++;
    }

    // Если ключ не найден, возвращаем пустую строку
    return "";
}

int main() {
    string values_line, template_str, result; // Объявляем три строки: исходные пары, шаблон и результат

    getline(cin, values_line);   // Считываем строку с парами ключ=значение (например: "name=John, age=30")
    getline(cin, template_str);  // Считываем шаблонную строку, содержащую плейсхолдеры в квадратных скобках (например: "Hello, [name]! You are [age] years old.")

    size_t pos = 0; // Позиция в шаблонной строке для поиска плейсхолдеров

    // Основной цикл по шаблону, пока не дошли до конца строки
    while (pos < template_str.size()) {
        // Ищем открывающую квадратную скобку '['
        size_t open_bracket = template_str.find('[', pos);

        // Если скобка не найдена — просто добавляем остаток строки к результату и выходим из цикла
        if (open_bracket == string::npos) {
            result += template_str.substr(pos);
            break;
        }

        // Добавляем к результату часть шаблона перед скобкой (от pos до open_bracket)
        result += template_str.substr(pos, open_bracket - pos);

        // Ищем закрывающую квадратную скобку ']' после найденной открывающей
        size_t close_bracket = template_str.find(']', open_bracket + 1);

        // Если закрывающей скобки нет — значит незакрытый плейсхолдер, добавляем '[' и идём дальше
        if (close_bracket == string::npos) {
            result += '[';
            pos = open_bracket + 1;
            continue;
        }

        // Извлекаем имя плейсхолдера — текст между '[' и ']'
        string placeholder = template_str.substr(open_bracket + 1, close_bracket - open_bracket - 1);

        bool found = false; // Флаг, найден ли плейсхолдер в строке ключ=значение
        string value = find_value_manually(values_line, placeholder, found); // Ищем значение по ключу

        if (found)
            result += value; // Если найдено — вставляем значение
        else
            // Если не найдено — вставляем плейсхолдер в исходном виде, включая квадратные скобки
            result += template_str.substr(open_bracket, close_bracket - open_bracket + 1);

        // Сдвигаем позицию поиска после закрывающей скобки
        pos = close_bracket + 1;
    }

    cout << result << endl; // Выводим итоговую строку с заменёнными плейсхолдерами (или с ними же, если ключи не найдены)

    return 0; // Возвращаем 0 — программа завершилась успешно
}
